<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Sorting</title>
<script type="text/javascript" src="plugins/d3/d3.min.js"></script>
<script type="text/javascript" src="plugins/jquery/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="plugins/slider/rangeslider.js"></script>

<link rel="stylesheet" type="text/css" href="source/css/style.css">
<link type="text/css" rel="stylesheet" href="plugins/slider/rangeslider.css">

</head>
<body>

<div class="topHeader">
	<label class="heading">Sorting</label>
	<a href="#" id="bubbleSort" class="sortLink selectedSort" index="1">Bubble</a>
	<a href="#" id="selectionSort" class="sortLink" index="2">Selection</a>
	<a href="#" id="insertionSort" class="sortLink" index="3">Insertion</a>
	<a href="#" id="mergeSort" class="sortLink" index="4">Merge</a>
	<a href="#" id="quickSort" class="sortLink" index="5">Quick</a>

	<a href="#" class="topbarLinks" style="margin-left:100px;">
		<label>Values</label>
		<div class="topbarDataDiv" id="valuesDiv">
			<input type="text" class="inputValues" value="34,26,85,36,78,22,66,99,35,26,75">
			<input type="button" value="GO" id="updateInputValues">
		</div>
	</a>
	<a href="#" class="topbarLinks">
		<label>Speed</label>
		<div class="topbarDataDiv" id="speedDiv">
			<input type="hidden" value="1000" id="animationSpeedValue">
			<input id="animationSpeed" type="range" min="200" max="5000" value="4200" class="rangeSliders" data-rangeslider >
		</div>
	</a>

	<a href="#" id="explanationLink" class="topbarLinks">
		<label>Explanation</label>
		<div class="topbarDataDiv" id="explanationDiv"></div>
	</a>
	<input type="button" value="Start" id="startSorting">



</div>
<div class="playGroundDiv">
	<svg width="1000px" height="500px" style="border:1px solid #ddd;"></svg>
</div>


<div id="validationErrorMessage"></div>


<div class="explanationsContainer">
	<div id="bubbleSortExplanation">
		<p>
			<h3>Bubble Sort</h3>
			Probably the slowest or the most inefficient of all the algorithms but on the other hand the whole process is really easy to understand and to manipulate.
		</p>
		<p>
			<h3>How Bubble Sort works?</h3>
			<p>The process is simple, you keep comparing pairs of adjacent elements of the sequence, if the they are in the wrong order swap them and do this till there are no swappings to do.</p>
			<p>ex: Sort an array {5,3,1,4,2} using Bubble Sort</p>
			<ul>
				<li>{5,3,1,4,2} Compare first two, as 5 > 3, they are swapped</li>
				<li>{3,5,1,4,2} Again compare next two, as 5 >1, they are swapped</li>
				<li>{3,1,5,4,2} Like this it keep swapping and iterate[go through] all the elements once to get this</li>
				<li>{3,1,4,2,5} Now they start doing the second run, comapre 3 & 1, as 3 > 1 they are swapped</li>
				<li>{1,3,4,2,5} compare 3,4 they are in correct order</li>
			</ul>
			<p>Like wise you compare till no swaps occurr while examining the whole sequence and then the function says "im done with this" and the looping stops;</p>
			<p>
				<h3>Efficiency</h3>
				Best case : O(n)<br>Avarage case: O(n^2)<br>Worst case: O(n^2)
			</p>
		</p>
	</div>
	<div id="selectionSortExplanation">
		<p>
			<h3>Selection Sort</h3>
			Just like the Bubble Sort the implementation and the idea behind is extremely simple. The following method will be used:
			<ol>
				<li>Loop the no. of elements times (that's loop 10 times if there are 10 numbers in the sequence).</li>
				<li>Find the minimum number in each case (That's you loop again in the whole array starting from one element after the current element and till end to search for a value smaller than the current element)</li>
				<li>If there's a minimum, swap the minimum with the current, so always the minimum would go the front of the list.</li>
			</ol>
		</p>
		<p>
			<h3>How Selection Sort Works?</h3>
			<ul>
				<li>{5,6,3,4,2} First we start our main loop to iterate though the sequence, and we find number 5. We store the number and the index.</li>
				<li>{5,6,3,4,2} Now we go searching in the REST OF THE NUMBERS to find a smaller value. We start from 6 as it's the immediate one after 5 (current element)</li>
				<li>{5,6,3,4,2} 6 > 5 so the no minimum found yet, then move to next and it is 3. Yeah 3 < 5 a min. We swap now? NO. we store it as our minimum.</li>
				<li>{5,6,3,4,2} Next we get 4, as 4 > 3, min is still 3, then we find 2 and 2 < 3 so clearly 2 is the minimum in the list (inner loop ends now). Now we swap the places of 2 and 5.</li>
				<li>{2,6,3,4,5} Next in our main loop we continue and we find 6. Again go scanning this time starting with 3 as it is the immediate one after 6. We find 3 as the smallest from the sequence (excluding 2,6). And we swap.</li>
				<li>{2,3,6,4,5} Likewise we go till the main loop is over and we get the sorted array.</li>
				<li>{2,3,4,5,6} There's a little increase of the efficiency but let's go there later.</li>
			</ul>
		</p>
		<p>
			<h3>Efficiency</h3>
			Avarage case: O(n log n)<br>Worst case: O(n^2)
		</p>
	</div>
	<div id="insertionSortExplanation">
		<p>
			<h3>Insertion Sort</h3>
			Like most of the sorting algorithms, this too has the core concept of "swapping: but instead of saving the swaps like in the Selection Sort, this algorithm concerns more about saving the times which the inner loops will run, saving us some valuable CPU calls at the same time dedicating swaps. however the algorithms is know the be really efficient for part sorted, or almost sorted arrays or sequence in which the time taken for sorting would decrease drastically when compared to other Bubble Sort and Selection Sort which have a constant time for the sorting in most of the cases.
		</p>
		<p>
			<h3>How Insertion Sort works?</h3>
			<ul>
				<li>{5,6,2,3,4} We start off with the second element that is, 5</li>
				<li>{6,5,2,3,4} We start by backtracking from the element before the selected, that is 6. The condition for the backtracking to end is that either the item being backtracked [compared to the selected element] is lower than the selected or the start of the array is reached [that is the index no of the backtrack is 0]</li>
				<li>{5,6,2,3,4} As 6 > 5 and 6's index no is 1, the swap is done between 5 & 6. Still the backtracking hasnt ended.</li>
				<li>{5,6,2,3,4} We check what's the one before 5 now, ah it is the start if the array, now we can safely put the END IT signal and goto the next element, that is third [index no. 2], 2.</li>
				<li>{5,2,6,3,4} When 2 is compared with 6, as 6 > 2 they are swapped</li>
				<li>{2,5,6,3,4} When 2 is compared with 5, as 5 > 2, they are swapped</li>
				<li>{2,5,6,3,4} Ouch! the start of the array, so the loop ends. Like wise it goes till the last element is processed like this.</li>
			</ul>
		</p>
		<p>
			<h3>Efficiency</h3>
			Best case : O(n)<br>Avarage case: O(n^2)<br>Worst case: O(n^2)
		</p>
	</div>
	<div id="mergeSortExplanation">
		<p>
			<h3>Merge Sort</h3>
			This algorithm works on the basis of Divide and Conquer strategy i.e. dividing the problem into sub problems, solving the sub problems independently and then merging the outcomes of the sub problems to get the outcome of the actual problem. 
		</p>
		<p>
			<h3>How Insertion Sort works?</h3>
			If we need to mergesort 24,13,26,1,2,27,38,15, we would divide the problem into the subproblems of sorting 24,13,26,1 and 2,27,38,15 independently, get the outcomes 1,13,24,26 and 2,15,27,38 and then merging the outcomes to get the result 1,2,13,15,24,26,27,38.
		</p>
		<p>
			<h3>Efficiency</h3>
			Best case : O(n log n)<br>Avarage case: O(n log n)<br>Worst case: O(n log n)
		</p>
	</div>
	<div id="quickSortExplanation">
		<p>
			<h3>Quick sort</h3>
			<ol>
				<li>Pick an element from the list (usually the most left element is used). This element will serve as a pivot point</li>
				<li>Reorder the list so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). This is called the partition operation.</li>
				<li>Recursively repeat the algorithm for both halves of the original array.</li>
			</ol>
		</p>
		<p>
			<h3>How Quick Sort works?</h3>
			<ul>
				<li>{5,6,2,3,4} We start off with the left most element that is, 5 as pivot element.</li>
				<li>Find position of pivot element. Here 5 should be in 4th position. So reorder the list so that all elements with values less than the pivot come before the 4th position, while all elements with values greater than the pivot come after it. So now list order now is {3,4,2,5,6}</li>
				<li>Now 5 is sorted. Apply same quick sort for left set and right set.</li>
				<li>Now all elements are Sorted.</li>
			</ul>
		</p>
		<p>
			<h3>Efficiency</h3>
			Best case : O(n log n)<br>Avarage case: O(n log n)<br>Worst case: O(n^2)
		</p>
	</div>
</div>


</body>

<script type="text/javascript" src="source/js/main.js"></script>

<script type="text/javascript">

function callSorting(){
	var inputData = $(".inputValues").val().split(",");
	var inputValues = new Array();
	for (var i = 0; i < inputData.length; i++) {
		inputValues[i] = parseInt(inputData[i]);
	};
	$(document).sorting({
		speed : 1000,
		data : inputValues
	});
}
callSorting();


$(".topbarLinks label").click(function(event){
	$(".topbarDataDiv").hide();
	$(this).parent("a").find(".topbarDataDiv").toggle();
});

$("#explanationLink label").click(function(){
	var index = parseInt($(".selectedSort").attr("index"));
	$("#explanationDiv").html("");
	switch(index){
		case 1:
			$("#explanationDiv").html($("#bubbleSortExplanation").html())
			break;
		case 2:
			$("#explanationDiv").html($("#selectionSortExplanation").html())
			break;
		case 3:
			$("#explanationDiv").html($("#insertionSortExplanation").html())
			break;
		case 4:
			$("#explanationDiv").html($("#mergeSortExplanation").html())
			break;
		case 5:
			$("#explanationDiv").html($("#quickSortExplanation").html())
			break;
	}

});


$(document).mouseup(function (e)
{
    var container1 = $(".topbarLinks");
	// var container2 = $(".expIcon");
    if (!container1.is(e.target) // if the target of the click isn't the container...
        && container1.has(e.target).length === 0 // ... nor a descendant of the container
        // && !container2.is(e.target) && container2.has(e.target).length === 0 
        ) 
    {
    	$(".topbarDataDiv").hide();
    }
});



</script>


</html>